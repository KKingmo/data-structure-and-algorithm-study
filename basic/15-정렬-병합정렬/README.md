## 병합정렬

- divide and conquer(분할 정복)

  - 해결하기 힘든 문제가 발생한다면 이걸 한 번에 해결하려고 하지 말고, 해결하기 쉬울 정도로 문제를 쪼갠 다음 하나씩 해결하라.  
    아래 배열의 정렬 한다고 가정해보자.  
    <img src="./img/1.png">  
    처음부터 8개의 숫자를 정렬한다고 생각하면 복잡하다.  
    이를 반으로 쪼개보자.  
    `[3, 5, 2, 4]`, `[1, 7, 8, 6]`  
    원소 네 개가 들어있는 배열은 여덟 개가 들어있는 배열보다 정렬하기 쉽다.  
    여기서 또 각 배열을 반으로 쪼개보자.  
    `[3, 5]`, `[2, 4]`, `[1, 7]`, `[8, 6]`  
    이렇게 되면 더 정렬하기가 쉬워진다.  
    두 개를 비교해서 더 작은 값이 앞으로 오도록 자리를 바꿔주면 되기 때문이다.  
    뇌절 같지만 여기서 한번 더 쪼개보자.  
    `[3]`, `[5]`, `[2]`, `[4]`, `[1]`, `[7]`, `[8]`, `[6]`  
    이렇게 되면 배열에 요소가 하나 씩밖에 없으므로 정렬할 필요가 없다.  
    이제 분할했던 배열을 순서대로 병합해 보자.  
    `[3, 5]`, `[2, 4]`, `[1, 7]`, `[6, 8]`  
    이렇게되면 각 배열의 두 요소는 전부 정렬된다.  
    여기서 두 배열을 씩 묶어서 순서대로 병합해 보자.  
    `[2, 3, 4, 5]`, `[1, 6, 7, 8]`  
    마지막으로 두 배열을 순서대로 병합해 보자.  
    `[1, 2, 3, 4, 5, 6, 7, 8]`  
    이는 재귀함수를 호출하는 것과 비슷한 작업이다.  
    병합정렬은 재귀로 정렬하는 알고리즘이다.

- 병합정렬 구현

  - [Code Link](../dev/merge_sort.mjs)

- 병합정렬의 빅오
  - O(nlogn)

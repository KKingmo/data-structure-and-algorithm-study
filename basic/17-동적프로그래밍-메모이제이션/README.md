## 동적 프로그래밍 - 메모이제이션

- 재귀를 사용하면 함수가 콜스택에 쌓이는 단점 이외에도 성능에 크게 영향을 미치는 단점이 있다.
- 예시를 통해 이를 알아보자.
- 수학에는 피보나치 수열이라는 것이 있다.

  - `1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233`
  - 위 처럼 1과 1로 시작해 인접한 두 수룰 무한하게 더하는 수열을 피보나치 수열이라 한다.
  - 이를 재귀함수로 구현해보자.

    ```js
    function fibonacci(n) {
      if (n == 0 || n == 1) return n;
      return fibonacci(n - 2) + fibonacci(n - 1);
    }

    console.log(fibonacci(5));
    ```

- 이렇게 보면 재귀를 이용해 피보나치를 성공적으로 구현한 것처럼 보이나 성능이 별로 좋지 못하다.
- 우리가 만든 함수는 같은 계산을 하는 경우가 많이 발생한다.
- fibonacci(5)를 호출할 때 하향식 계산에 의해 fibonacci(3), fibonacci(2), fibonacci(1)은 중복 실행되지만
- 매 함수 호출마다 일일히 계산한다.
- 이는 fibonacci(3), fibonacci(2), fibonacci(1)가 처음 호출 되었을 때 값을 저장한 다음
- 같은 계산이 필요할 때는 계산을 다시하지않고 저장한 값을 사용한다면 성능을 향상할 수 있다.
- 이를 위한 개념이 메모이제이션이다.
- 메모이제이션은 계산 결과를 저장해서 여러 번 계산하지 않도록 하는 기법이다.
- 피보나치 함수를 메모이제이션을 사용해 성능을 향상해보자.
- 이를 구현하는 방법에 대해 생각해보자.
- 계산하려는 데이터가 있는지 검색하고, 없다면 함수를 호출해 계산을 하고 그 결과를 저장시키면 된다.
- 이에 효율적인 데이터 구조로는 해시 테이블이 있다.
- 해시 테이블은 데이터 검색, 삽입이 굉장히 빠르다는 장점이 있다.
- 해시 테이블의 key로 계산하려는 값을, value로 계산 결과를 저장해준다면 계산하려는 값의 검색을 아주 빨리 할 수 있을 것이다.
  | Key | Value |
  | :-: | :---: |
  | 3 | 2 |
- 자바스크립트 객체는 해시 테이블이기 때문에 자바스크립트에서는 객체를 사용하면 편하다.

---

- 재귀함수로 구현한 피보나치 수열에 메모이제이션 적용 후 성능비교
  - [Code Link](../dev/fibonacci.mjs)
  - 위 `Code Link`에서 fibonacci1은 O(2^n), fibonacci2는 O(n)의 성능을 가진다.
  - n값이 커질 수록 둘의 성능 차이는 더욱 두드러지며 40번 째 항의 피보나치를 계산에는 약 1000배의 성능차이를 확인할 수 있었다.
  - 이것이 메모이제이션의 강력함이다.
  - 하지만 이러한 메모이제이션도 결국 함수를 여러 번 호출하는 재귀를 사용하기 때문에 함수 하나를 호출하는 것보다 오버헤드가 더 클 수밖에 없다.
- 오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.  
  예를 들어 A라는 처리를 단순하게 실행한다면 10초 걸리는데,  
  안전성을 고려하고 부가적인 B라는 처리를 추가한 결과 처리시간이 15초 걸렸다면 오버헤드는 5초가 된다.  
  또한 이 처리 B를 개선해 B'라는 처리를 한 결과,  
  처리시간이 12초가 되었다면, 이 경우 오버헤드가 3초 단축되었다고 말한다
